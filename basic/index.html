<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>pure webgl</title>
    <style>
        #container{
            width: 500px;
            height: 500px;
        }
    </style>
</head>
<body>
  
  <!-- 캔버스 정의 WebGL로 렌더링한 결과가 표시 됨 -->
  <canvas id="container"></canvas>

</body>

<!-- 버텍스 셰이더 작성 -->
<script id="2d-vertex-shader" type="notjs">
    /*
        WebgL은 단지 클립 좌표계와 색상을 도출하는데 목적이 있음.

        개발자는 이 목적을 달성하기 위해 WebGL에 2개의 셰이더를 제공해야 함.

        버텍스 셰이더는 클립 좌표계의 값을 제공
        프래그먼트 셰이더는 색상을 제공

        셰이더는 GPU가 어떻게 그림을 그려야 하는지 알려주는 명령 코드
        GLSL라는 특수 언어로 작성할 수 있음.

    */

    /* GLSL로 작성된 클립 좌표값을 도출할 버텍스 세이터 코드

       WebGL 좌표계 설명 : https://myounggun.github.io/webgl-coord/
    */
    
    /*  클립 좌표계는 canvas 크기에 상관 없이 항상 -1 ~ +1의 범위를 가짐
        [위 설명 링크의 클립 영역 참조]

    */

    attribute vec4 a_position; // attribute는 buffer로 부터 데이터를 받을 것임.

    /* 모든 데이터는 main 함수를 가짐 */
    void main(){

        /* gl_Position은 버텍스 셰이더에서 설정을 담당하는 특수한 변수 */
        gl_Position = a_position;

        

    }


</script>
 
<!-- 프래그먼트 셰이더 작성 -->
<script id="2d-fragment-shader" type="notjs">
</script>

<!-- 설명

    위의 스크립트 두곳은 각각 버텍스 셰이더와 프래그먼트 셰이더가 작성됨

-->

<!--
    type=”notjs”에 주목해보면 notjs가 무엇을 의미한다기 보다
    브라우저에게 여기에서 작성된 코드는 javascript가 아닌
    그 무엇도 아닌 코드다라고 알려줌

    즉 브라우저는 <script></script> 내에 작성된 문자열을 따로 해석하지 않고
    화면 출력도 없이 넘어감.

    여기서는 <script>내에 작성되지만 셰이더 코드는 그저 텍스일 뿐임
    ajax로 가져와도 되고 javascript의 하나의 변수에 작성해도 무방함.
-->

<!-- WebGL 자바스크립트 코드를 작성함
     이곳에는 일반 javacript 코드와 셰이더를 컴파일하고
     셰이더에서 쓰일 데이터를 공급해주며
     실행하기 위해 WebGL API로 작성된 javascript 코드들이 작성 됨.
-->
<script>
    var
        container;

    window.onload = function(){
        container = document.getElementById("container");
        console.log(container);

    }

</script>

</html>